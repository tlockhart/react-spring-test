{"ast":null,"code":"import _createClass from \"E:/react-three-fiber/react-spring-test/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"E:/react-three-fiber/react-spring-test/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { invalidate, addEffect, applyProps } from '@react-three/fiber';\nimport { Globals as Globals$1 } from '@react-spring/core';\nexport * from '@react-spring/core';\nimport { Globals, flushCalls, createStringInterpolator, colors } from '@react-spring/shared';\nimport { createHost } from '@react-spring/animated';\nimport * as THREE from 'three';\n\nvar batchedUpdates = function batchedUpdates(callback) {\n  return callback();\n};\n\nvar now = function now() {\n  return performance.now();\n};\n\nvar FrameLoop = /*#__PURE__*/_createClass(function FrameLoop(raf) {\n  _classCallCheck(this, FrameLoop);\n\n  var idle = true;\n  var writing = false;\n  var lastTime = 0;\n  var currentFrame = [];\n  var prevFrame = [];\n  var priority = 0;\n  var startQueue = new Set();\n  var frameQueue = new Set();\n  var writeQueue = new Set();\n\n  var start = function start(animation) {\n    return currentFrame.indexOf(animation) < 0 && currentFrame.splice(findIndex(currentFrame, function (existing) {\n      return existing.priority > animation.priority;\n    }), 0, animation);\n  };\n\n  var loop = function loop() {\n    if (idle) return;\n    raf(loop);\n\n    try {\n      advance();\n    } catch (e) {\n      console.error(e);\n    }\n  };\n\n  var kickoff = function kickoff() {\n    if (idle) {\n      idle = false;\n\n      if (lastTime == 0) {\n        lastTime = now();\n        raf(loop);\n      }\n    }\n  };\n\n  var timeoutQueue = [];\n\n  this.setTimeout = function (handler, ms) {\n    var time = now() + ms;\n\n    var cancel = function cancel() {\n      var index2 = timeoutQueue.findIndex(function (t) {\n        return t.cancel == cancel;\n      });\n\n      if (index2 >= 0) {\n        timeoutQueue.splice(index2, 1);\n      }\n    };\n\n    var index = findIndex(timeoutQueue, function (t) {\n      return t.time > time;\n    });\n    var timeout = {\n      time: time,\n      handler: handler,\n      cancel: cancel\n    };\n    timeoutQueue.splice(index, 0, timeout);\n    kickoff();\n    return timeout;\n  };\n\n  var advance = this.advance = function () {\n    var time = now();\n\n    if (startQueue.size) {\n      startQueue.forEach(start);\n      startQueue.clear();\n    }\n\n    if (timeoutQueue.length) {\n      batchedUpdates(function () {\n        var count = findIndex(timeoutQueue, function (t) {\n          return t.time > time;\n        });\n        timeoutQueue.splice(0, count).forEach(function (t) {\n          return t.handler();\n        });\n      });\n    }\n\n    if (time > lastTime) {\n      var dt = Math.min(64, time - lastTime);\n      lastTime = time;\n      batchedUpdates(function () {\n        if (currentFrame.length) {\n          var nextFrame = prevFrame;\n\n          for (var i = 0; i < currentFrame.length; i++) {\n            var animation = currentFrame[i];\n            priority = animation.priority;\n\n            if (!animation.idle) {\n              Globals.willAdvance(animation);\n              animation.advance(dt);\n\n              if (!animation.idle) {\n                nextFrame.push(animation);\n              }\n            }\n          }\n\n          priority = 0;\n          prevFrame = currentFrame;\n          prevFrame.length = 0;\n          currentFrame = nextFrame;\n        }\n\n        flushCalls(frameQueue, time);\n\n        if (writeQueue.size) {\n          writing = true;\n          flushCalls(writeQueue, time);\n          writing = false;\n        }\n      });\n    }\n  };\n\n  this.start = function (animation) {\n    if (priority > animation.priority) {\n      startQueue.add(animation);\n    } else {\n      start(animation);\n      kickoff();\n    }\n  };\n\n  this.onFrame = function (cb) {\n    frameQueue.add(cb);\n    kickoff();\n  };\n\n  this.onWrite = function (cb) {\n    if (writing) cb(lastTime);else writeQueue.add(cb);\n  };\n\n  if (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n    var isIdle = function isIdle() {\n      return !startQueue.size && !currentFrame.length && !timeoutQueue.length;\n    };\n\n    var dispose = function dispose() {\n      idle = true;\n      startQueue.clear();\n      timeoutQueue.length = 0;\n    };\n\n    Object.defineProperties(this, {\n      _idle: {\n        get: isIdle\n      },\n      _dispose: {\n        get: function get() {\n          return dispose;\n        }\n      }\n    });\n  }\n});\n\nfunction findIndex(arr, test) {\n  var index = arr.findIndex(test);\n  return index < 0 ? arr.length : index;\n}\n\nvar primitives = [\"primitive\"].concat(Object.keys(THREE).filter(function (key) {\n  return /^[A-Z]/.test(key);\n}).map(function (key) {\n  return key[0].toLowerCase() + key.slice(1);\n}));\nvar frameLoop = new FrameLoop(function () {\n  return invalidate();\n});\naddEffect(function () {\n  frameLoop.advance();\n  return true;\n});\nGlobals$1.assign({\n  createStringInterpolator: createStringInterpolator,\n  colors: colors,\n  frameLoop: frameLoop\n});\nvar host = createHost(primitives, {\n  applyAnimatedValues: applyProps\n});\nvar animated = host.animated;\nexport { animated as a, animated };","map":{"version":3,"sources":["src/FrameLoop.ts","src/primitives.ts","src/index.ts"],"names":["FrameLoop2","Globals","primitives2"],"mappings":"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","sourcesContent":["import { invalidate, addEffect, applyProps } from '@react-three/fiber';\nimport { Globals as Globals$1 } from '@react-spring/core';\nexport * from '@react-spring/core';\nimport { Globals, flushCalls, createStringInterpolator, colors } from '@react-spring/shared';\nimport { createHost } from '@react-spring/animated';\nimport * as THREE from 'three';\n\nlet batchedUpdates = (callback) => callback();\nlet now = () => performance.now();\nclass FrameLoop {\n  constructor(raf) {\n    let idle = true;\n    let writing = false;\n    let lastTime = 0;\n    let currentFrame = [];\n    let prevFrame = [];\n    let priority = 0;\n    const startQueue = new Set();\n    const frameQueue = new Set();\n    const writeQueue = new Set();\n    const start = (animation) => currentFrame.indexOf(animation) < 0 && currentFrame.splice(findIndex(currentFrame, (existing) => existing.priority > animation.priority), 0, animation);\n    const loop = () => {\n      if (idle)\n        return;\n      raf(loop);\n      try {\n        advance();\n      } catch (e) {\n        console.error(e);\n      }\n    };\n    const kickoff = () => {\n      if (idle) {\n        idle = false;\n        if (lastTime == 0) {\n          lastTime = now();\n          raf(loop);\n        }\n      }\n    };\n    const timeoutQueue = [];\n    this.setTimeout = (handler, ms) => {\n      const time = now() + ms;\n      const cancel = () => {\n        const index2 = timeoutQueue.findIndex((t) => t.cancel == cancel);\n        if (index2 >= 0) {\n          timeoutQueue.splice(index2, 1);\n        }\n      };\n      const index = findIndex(timeoutQueue, (t) => t.time > time);\n      const timeout = {time, handler, cancel};\n      timeoutQueue.splice(index, 0, timeout);\n      kickoff();\n      return timeout;\n    };\n    const advance = this.advance = () => {\n      const time = now();\n      if (startQueue.size) {\n        startQueue.forEach(start);\n        startQueue.clear();\n      }\n      if (timeoutQueue.length) {\n        batchedUpdates(() => {\n          const count = findIndex(timeoutQueue, (t) => t.time > time);\n          timeoutQueue.splice(0, count).forEach((t) => t.handler());\n        });\n      }\n      if (time > lastTime) {\n        const dt = Math.min(64, time - lastTime);\n        lastTime = time;\n        batchedUpdates(() => {\n          if (currentFrame.length) {\n            const nextFrame = prevFrame;\n            for (let i = 0; i < currentFrame.length; i++) {\n              const animation = currentFrame[i];\n              priority = animation.priority;\n              if (!animation.idle) {\n                Globals.willAdvance(animation);\n                animation.advance(dt);\n                if (!animation.idle) {\n                  nextFrame.push(animation);\n                }\n              }\n            }\n            priority = 0;\n            prevFrame = currentFrame;\n            prevFrame.length = 0;\n            currentFrame = nextFrame;\n          }\n          flushCalls(frameQueue, time);\n          if (writeQueue.size) {\n            writing = true;\n            flushCalls(writeQueue, time);\n            writing = false;\n          }\n        });\n      }\n    };\n    this.start = (animation) => {\n      if (priority > animation.priority) {\n        startQueue.add(animation);\n      } else {\n        start(animation);\n        kickoff();\n      }\n    };\n    this.onFrame = (cb) => {\n      frameQueue.add(cb);\n      kickoff();\n    };\n    this.onWrite = (cb) => {\n      if (writing)\n        cb(lastTime);\n      else\n        writeQueue.add(cb);\n    };\n    if (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n      const isIdle = () => !startQueue.size && !currentFrame.length && !timeoutQueue.length;\n      const dispose = () => {\n        idle = true;\n        startQueue.clear();\n        timeoutQueue.length = 0;\n      };\n      Object.defineProperties(this, {\n        _idle: {get: isIdle},\n        _dispose: {get: () => dispose}\n      });\n    }\n  }\n}\nfunction findIndex(arr, test) {\n  const index = arr.findIndex(test);\n  return index < 0 ? arr.length : index;\n}\n\nconst primitives = [\"primitive\"].concat(Object.keys(THREE).filter((key) => /^[A-Z]/.test(key)).map((key) => key[0].toLowerCase() + key.slice(1)));\n\nconst frameLoop = new FrameLoop(() => invalidate());\naddEffect(() => {\n  frameLoop.advance();\n  return true;\n});\nGlobals$1.assign({\n  createStringInterpolator,\n  colors,\n  frameLoop\n});\nconst host = createHost(primitives, {\n  applyAnimatedValues: applyProps\n});\nconst animated = host.animated;\n\nexport { animated as a, animated };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}